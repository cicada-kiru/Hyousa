package hyousa.dfs.server.master.netty;import hyousa.common.conf.Configuration;import hyousa.common.rpc.Result;import hyousa.common.rpc.client.netty.NettyRpcClient;import hyousa.common.rpc.client.netty.SerializableInvocation;import hyousa.dfs.server.master.FileAlreadyExistsException;import hyousa.dfs.server.master.InvalidPathException;import hyousa.dfs.server.master.NoSuchFileException;import hyousa.dfs.server.master.protocol.BlockLocations;import hyousa.dfs.server.master.protocol.FileStatus;import hyousa.dfs.server.master.protocol.MasterHeartbeatResponse;import hyousa.dfs.server.master.protocol.MasterProtocol;import java.io.IOException;import java.io.Serializable;/** * Created by yousa on 2017/12/11. */public class NettyMasterRpcClient extends NettyRpcClient implements MasterProtocol {    public NettyMasterRpcClient(String host, int port, Configuration conf) {        super(host, port, conf);    }    /**     * Create a file with the given name and blocks information     *     * @param name The created file name     * @param path The file being created under the path     * @param size The file length     * @throws NoSuchFileException        If the path dir not exists     * @throws FileAlreadyExistsException If the path is a file     */    public String[] create(String name, String path, long size) throws NoSuchFileException, FileAlreadyExistsException {        Result result = invoke(            new SerializableInvocation(                "create",                new Class<?>[]{String.class, String.class, long.class},                new Serializable[]{name, path, size}            )        );        if (result.hasError()) {            Throwable e = result.getCause();            if (e instanceof NoSuchFileException) throw (NoSuchFileException) e;            else throw (FileAlreadyExistsException) e;        }        return (String[]) result.getResult();    }    /**     * Get the blocks of a file and the locations of the blocks     *     * @param path The file path     * @return Block locations array     * @throws NoSuchFileException If the path not exists or the path is a directory     */    public BlockLocations[] getBlockLocations(String path) throws NoSuchFileException {        Result result = invoke(            new SerializableInvocation(                "getBlockLocations",                new Class<?>[]{String.class},                new Serializable[]{path}            )        );        if (result.hasError()) {            throw (NoSuchFileException) result.getCause();        }        return (BlockLocations[]) result.getResult();    }    /**     * Add the blocks of a file to block manager     *     * @param blocks Block locations array     */    public void addBlockLocations(BlockLocations[] blocks) {        invoke(            new SerializableInvocation(                "addBlockLocations",                new Class<?>[]{BlockLocations[].class},                new Serializable[]{blocks}            )        );    }    /**     * List the files under the path     *     * @param path The listed path     * @return The files under the path     * @throws NoSuchFileException        If the path dir not exists     * @throws FileAlreadyExistsException If the path is a file     */    public FileStatus[] listDir(String path) throws NoSuchFileException, FileAlreadyExistsException {        Result result = invoke(            new SerializableInvocation(                "listDir",                new Class<?>[]{String.class},                new Serializable[]{path}            )        );        if (result.hasError()) {            Throwable e = result.getCause();            if (e instanceof NoSuchFileException) throw (NoSuchFileException) e;            else throw (FileAlreadyExistsException) e;        }        return (FileStatus[]) result.getResult();    }    /**     * Rename a file or a directory     *     * @param path The path to be renamed     * @param name The path new name     * @throws InvalidPathException       If path is root directory     * @throws NoSuchFileException        If path not exists     * @throws FileAlreadyExistsException If new name already in the path parent dir     */    public void rename(String path, String name) throws NoSuchFileException, FileAlreadyExistsException, InvalidPathException {        Result result = invoke(            new SerializableInvocation(                "rename",                new Class<?>[]{String.class, String.class},                new Serializable[]{path, name}            )        );        if (result.hasError()) {            Throwable e = result.getCause();            if (e instanceof NoSuchFileException) throw (NoSuchFileException) e;            else if (e instanceof FileAlreadyExistsException) throw (FileAlreadyExistsException) e;            else throw (InvalidPathException) e;        }    }    /**     * Create directories (allows hierarchy of directories)     *     * @param paths The paths of the directories to be created     * @throws FileAlreadyExistsException If path already exists     */    public void mkdir(String... paths) throws FileAlreadyExistsException {        Result result = invoke(            new SerializableInvocation(                "mkdir",                new Class<?>[]{String[].class},                new Serializable[]{paths}            )        );        if (result.hasError()) {            throw (FileAlreadyExistsException) result.getCause();        }    }    /**     * Move src(a file or a directory) to target directory     *     * @param src    The path to be moved     * @param target The target path     * @throws InvalidPathException       If path is root directory, or src and target are the same     * @throws FileAlreadyExistsException If target path is a file     * @throws NoSuchFileException        If src not exists     */    public void move(String src, String target) throws NoSuchFileException, FileAlreadyExistsException, InvalidPathException {        Result result = invoke(            new SerializableInvocation(                "move",                new Class<?>[]{String.class, String.class},                new Serializable[]{src, target}            )        );        if (result.hasError()) {            Throwable e = result.getCause();            if (e instanceof NoSuchFileException) throw (NoSuchFileException) e;            else if (e instanceof FileAlreadyExistsException) throw (FileAlreadyExistsException) e;            else throw (InvalidPathException) e;        }    }    /**     * Delete the given file or directory from the file system     *     * @param path existing name     * @throws InvalidPathException If path is root directory     * @throws NoSuchFileException  If the file or directory not exists     */    public void remove(String path) throws NoSuchFileException, InvalidPathException {        Result result = invoke(            new SerializableInvocation(                "remove",                new Class<?>[]{String.class},                new Serializable[]{path}            )        );        if (result.hasError()) {            Throwable e = result.getCause();            if (e instanceof NoSuchFileException) throw (NoSuchFileException) e;            else throw (InvalidPathException) e;        }    }    /**     * Register slave to master     *  @param slaveId  The registered slave     * @param blockIds The blocks slave maintaining     */    public String[] registerSlave(String slaveId, String[] blockIds) {        return (String[]) invoke(            new SerializableInvocation(                "registerSlave",                new Class<?>[]{String.class, String[].class},                new Serializable[]{slaveId, blockIds}            )        ).getResult();    }    /**     * Send heartbeat to master     *     * @return The response of master     */    public MasterHeartbeatResponse sendHeartbeat() {        return (MasterHeartbeatResponse) invoke(new SerializableInvocation("sendHeartbeat")).getResult();    }    public void dump() throws IOException {        Result result = invoke(new SerializableInvocation("dump"));        if (result.hasError()) throw (IOException) result.getCause();    }}